// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['underscore', 'jquery', './socket'], function(_, $, socket) {
    var Ball, BallGraphic, Game, Graphics, Physics, Player, PlayerGraphic, Shape, Stage, Ticker, Vector, canvas, config, player, stage, start;
    Stage = createjs.Stage;
    Graphics = createjs.Graphics;
    Shape = createjs.Shape;
    Ticker = createjs.Ticker;
    config = {
      width: $('canvas').width(),
      height: $('canvas').height()
    };
    canvas = $('#playingfield');
    canvas.width(config.width);
    canvas.height(config.height);
    stage = new createjs.Stage(canvas[0]);
    player = null;
    Vector = {
      dotProduct: function(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      },
      scale: function(s, v) {
        return [v[0] * s, v[1] * s];
      },
      length: function(v) {
        return Math.pow(v[0] * v[0] + v[1] * v[1], 0.5);
      },
      add: function(v1, v2) {
        return [v1[0] + v2[0], v1[1] + v2[1]];
      },
      subtract: function(v1, v2) {
        return [v1[0] - v2[0], v1[1] - v2[1]];
      },
      normalize: function(v) {
        var l;
        l = this.length(v);
        return [v[0] / l, v[1] / l];
      },
      reflect: function(v, n) {
        return this.subtract(v, this.scale(2 * this.dotProduct(v, n), n));
      }
    };
    Physics = {
      circleCollisionNormal: function(c1, c2) {
        return Vector.normalize(Vector.subtract(c2.position, c1.position));
      },
      separation: function(p1, p2) {
        return Math.pow(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2), 0.5);
      },
      testCircleCircleCollision: function(c1, c2) {
        var radiusSum, separation;
        separation = this.separation(c1.position, c2.position);
        radiusSum = c1.radius + c2.radius;
        return separation <= radiusSum;
      },
      collideBallWithPlayer: function(ball, player) {
        var normal, overlapDistance, overlapVector, radiusSum;
        overlapVector = Vector.subtract(player.position, ball.position);
        radiusSum = ball.radius + player.radius;
        overlapDistance = Vector.length(overlapVector) - radiusSum;
        if (overlapDistance <= 0) {
          normal = Vector.normalize(overlapVector);
          ball.velocity = Vector.reflect(ball.velocity, normal);
          return ball.position = Vector.add(ball.position, Vector.scale(overlapDistance, normal));
        }
      },
      collideBallWithEdges: function(ball) {
        var r, x, y;
        x = ball.position[0];
        y = ball.position[1];
        r = ball.radius;
        if (x <= r) {
          return ball.velocity = Vector.reflect(ball.velocity, [1, 0]);
        } else if (x >= config.width - ball.radius) {
          return ball.velocity = Vector.reflect(ball.velocity, [-1, 0]);
        } else if (y <= r) {
          return ball.velocity = Vector.reflect(ball.velocity, [0, 1]);
        } else if (y >= config.height - ball.radius) {
          return ball.velocity = Vector.reflect(ball.velocity, [0, -1]);
        }
      }
    };
    Ball = (function() {

      Ball.prototype.radius = 5;

      function Ball() {
        this.position = [config.width / 2, config.height / 2];
        this.graphic = new BallGraphic(this);
        this.velocity = [0.05, 0.05];
      }

      Ball.prototype.updatePosition = function(delta) {
        this.position[0] += this.velocity[0] * delta;
        return this.position[1] += this.velocity[1] * delta;
      };

      Ball.prototype.render = function(delta) {
        this.updatePosition(delta);
        return this.graphic.render(delta);
      };

      return Ball;

    })();
    Player = (function() {

      Player.prototype.radius = 10;

      function Player(id) {
        var _this = this;
        this.position = [250, 250];
        this.graphic = new PlayerGraphic(this);
        this.playerId = id;
        socket.on("player:" + this.playerId + ":move", function(pos) {
          return _this.updatePosition(pos);
        });
      }

      Player.prototype.updatePosition = function(p) {
        return this.position = Vector.add(this.position, [config.width * p[0], config.height * p[1]]);
      };

      Player.prototype.render = function() {
        return this.graphic.render();
      };

      return Player;

    })();
    PlayerGraphic = (function() {

      PlayerGraphic.prototype.color = [255, 0, 0];

      function PlayerGraphic(player) {
        this.player = player;
        this.g = new Graphics();
        this.g.beginStroke(Graphics.getRGB(0, 0, 0));
        this.g.drawCircle(0, 0, this.player.radius);
        this.circle = new Shape(this.g);
        this.circle.x = this.getX();
        this.circle.y = this.getY();
        stage.addChild(this.circle);
      }

      PlayerGraphic.prototype.getX = function() {
        return this.player.position[0];
      };

      PlayerGraphic.prototype.getY = function() {
        return this.player.position[1];
      };

      PlayerGraphic.prototype.render = function() {
        this.circle.x = this.getX();
        this.circle.y = this.getY();
        return stage.addChild(this.circle);
      };

      return PlayerGraphic;

    })();
    BallGraphic = (function(_super) {

      __extends(BallGraphic, _super);

      function BallGraphic() {
        return BallGraphic.__super__.constructor.apply(this, arguments);
      }

      BallGraphic.prototype.color = [255, 0, 0];

      return BallGraphic;

    })(PlayerGraphic);
    Game = (function() {

      function Game() {
        this.start = __bind(this.start, this);

        this.tick = __bind(this.tick, this);
        this.players = [];
        this.addBall();
      }

      Game.prototype.addPlayer = function(id) {
        return this.players.push(new Player(id));
      };

      Game.prototype.addBall = function() {
        return this.ball = new Ball();
      };

      Game.prototype.tick = function(delta) {
        var p, _i, _j, _len, _len1, _ref, _ref1;
        delta || (delta = 0);
        this.ball.render(delta);
        _ref = this.players;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          Physics.collideBallWithPlayer(this.ball, p);
        }
        Physics.collideBallWithEdges(this.ball);
        _ref1 = this.players;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          p = _ref1[_j];
          p.render(delta);
        }
        this.ball.render();
        return stage.update();
      };

      Game.prototype.start = function() {
        var _this = this;
        this.tick();
        Ticker.setFPS(30);
        Ticker.addListener(this.tick);
        return socket.on('player:new', function(id) {
          console.log('added player ', id);
          return _this.addPlayer(id);
        });
      };

      return Game;

    })();
    start = function() {
      socket.emit('gamespace:register', '');
      return socket.on('gamespace:register:ack', function() {
        var game;
        game = new Game();
        return game.start();
      });
    };
    return {
      start: start
    };
  });

}).call(this);
